MODEL CHECKER INPUT:
LTS: node (trans [pred] [succ])* props:
      0 c-trans [1] [1,2] b-trans [0,3] [0] a-trans [0,1,3] [0,1] props: [p,q,r]
      1 c-trans [0,3] [0,2] b-trans [1,2,3] [1,3] a-trans [0,2] [0,3] props: [p,q,r,s]
      2 c-trans [0,1,2] [2,3] b-trans [2,3] [1,2] a-trans [3] [1,3] props: [p,q,s]
      3 c-trans [2,3] [1,3] b-trans [1] [0,1,2] a-trans [1,2] [0,2] props: [r,s]
FORMULA: ((lam X -> ((X p) <=> false)) (lam Y -> Y))
Start model checker...
Step: ((lam X -> ((X p) <=> false)) (lam Y -> Y))
Calc: (lam Y -> Y) completely...
  Arguments: [[],[0],[0,1],[0,2],[0,3],[0,1,2],[0,1,3],[0,2,3],[1],[1,2],[1,3],[1,2,3],[0,1,2,3],[2],[2,3],[3],]
Variable Y does not exist in env map.
Argument [] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,1] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,2] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,1,2] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,1,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,2,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [1] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [1,2] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [1,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [1,2,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [0,1,2,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [2] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [2,3] is set for arg -> ns object.
Variable Y does not exist in env map.
Argument [3] is set for arg -> ns object.
Result: [[[]->[]],[[0]->[0]],[[0,1]->[0,1]],[[0,2]->[0,2]],[[0,3]->[0,3]],[[0,1,2]->[0,1,2]],[[0,1,3]->[0,1,3]],[[0,2,3]->[0,2,3]],[[1]->[1]],[[1,2]->[1,2]],[[1,3]->[1,3]],[[1,2,3]->[1,2,3]],[[0,1,2,3]->[0,1,2,3]],[[2]->[2]],[[2,3]->[2,3]],[[3]->[3]],]
Step: (lam X -> ((X p) <=> false))
Step: ((X p) <=> false)
Step: (false => (X p))
Step: (X p)
Calc: p completely...
Result: [0,1,2]
Step: X
Definition of sem for [[[]->[]],[[0]->[0]],[[0,1]->[0,1]],[[0,2]->[0,2]],[[0,3]->[0,3]],[[0,1,2]->[0,1,2]],[[0,1,3]->[0,1,3]],[[0,2,3]->[0,2,3]],[[1]->[1]],[[1,2]->[1,2]],[[1,3]->[1,3]],[[1,2,3]->[1,2,3]],[[0,1,2,3]->[0,1,2,3]],[[2]->[2]],[[2,3]->[2,3]],[[3]->[3]],] for [0,1,2] is false
 Case: App of p to X - Value of Arg: [0,1,2] - Value Total: []
Step: ~false
Step: false
 Case: Bot - Value: []
 Case: Negation of false - Value: [0,1,2,3]
 Case: Impl of false and (X p) - Value: [0,1,2,3]
Step: ((X p) => false)
Step: false
 Case: Bot - Value: []
Step: ~(X p)
Step: (X p)
Calc: p completely...
Result: [0,1,2]
Step: X
Definition of sem for [[[]->[]],[[0]->[0]],[[0,1]->[0,1]],[[0,2]->[0,2]],[[0,3]->[0,3]],[[0,1,2]->[0,1,2]],[[0,1,3]->[0,1,3]],[[0,2,3]->[0,2,3]],[[1]->[1]],[[1,2]->[1,2]],[[1,3]->[1,3]],[[1,2,3]->[1,2,3]],[[0,1,2,3]->[0,1,2,3]],[[2]->[2]],[[2,3]->[2,3]],[[3]->[3]],] for [0,1,2] is false
 Case: App of p to X - Value of Arg: [0,1,2] - Value Total: []
 Case: Negation of (X p) - Value: [0,1,2,3]
 Case: Impl of (X p) and false - Value: [0,1,2,3]
 Case: Equiv of (X p) and false - Value: [0,1,2,3]
 Case: Lambda X of ((X p) <=> false) - Value: [0,1,2,3]
 Case: App of (lam Y -> Y) to (lam X -> ((X p) <=> false)) - Value of Arg: [[[]->[]],[[0]->[0]],[[0,1]->[0,1]],[[0,2]->[0,2]],[[0,3]->[0,3]],[[0,1,2]->[0,1,2]],[[0,1,3]->[0,1,3]],[[0,2,3]->[0,2,3]],[[1]->[1]],[[1,2]->[1,2]],[[1,3]->[1,3]],[[1,2,3]->[1,2,3]],[[0,1,2,3]->[0,1,2,3]],[[2]->[2]],[[2,3]->[2,3]],[[3]->[3]],] - Value Total: [0,1,2,3]
RESULT: [0,1,2,3]

